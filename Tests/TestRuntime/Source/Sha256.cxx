#include "AnemoneRuntime/Platform/Base/BaseHeaders.hxx"
#include "AnemoneRuntime/Crypto/Sha256.hxx"

ANEMONE_EXTERNAL_HEADERS_BEGIN

#include <catch_amalgamated.hpp>

ANEMONE_EXTERNAL_HEADERS_END

TEST_CASE("Cryptography Sha256")
{
    using namespace Anemone::Crypto;

    Sha256Context context{};

    SECTION("Emtpy")
    {
        sha256_initialize(context);
        auto const hash = sha256_finalize(context);

        constexpr uint8_t expected[]{
            0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, 0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,
            0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c, 0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55};

        for (size_t i = 0; i < hash.size(); ++i)
        {
            REQUIRE(hash[i] == expected[i]);
        }
    }

    SECTION("foobar")
    {
        sha256_initialize(context);
        sha256_update(context, std::as_bytes(std::span{std::string_view{"foobar"}}));
        auto const hash = sha256_finalize(context);

        constexpr uint8_t expected[]{
            0xc3, 0xab, 0x8f, 0xf1, 0x37, 0x20, 0xe8, 0xad, 0x90, 0x47, 0xdd, 0x39, 0x46, 0x6b, 0x3c, 0x89,
            0x74, 0xe5, 0x92, 0xc2, 0xfa, 0x38, 0x3d, 0x4a, 0x39, 0x60, 0x71, 0x4c, 0xae, 0xf0, 0xc4, 0xf2};

        for (size_t i = 0; i < hash.size(); ++i)
        {
            REQUIRE(hash[i] == expected[i]);
        }
    }

    SECTION("binary data / 32 bytes")
    {
        constexpr uint8_t source[]{
            0xc3, 0xab, 0x8f, 0xf1, 0x37, 0x20, 0xe8, 0xad, 0x90, 0x47, 0xdd, 0x39, 0x46, 0x6b, 0x3c, 0x89,
            0x74, 0xe5, 0x92, 0xc2, 0xfa, 0x38, 0x3d, 0x4a, 0x39, 0x60, 0x71, 0x4c, 0xae, 0xf0, 0xc4, 0xf2};

        sha256_initialize(context);
        sha256_update(context, std::as_bytes(std::span{source}));
        auto const hash = sha256_finalize(context);

        constexpr uint8_t expected[]{
            0x3f, 0x2c, 0x7c, 0xca, 0xe9, 0x8a, 0xf8, 0x1e, 0x44, 0xc0, 0xec, 0x41, 0x96, 0x59, 0xf5, 0x0d,
            0x8b, 0x7d, 0x48, 0xc6, 0x81, 0xe5, 0xd5, 0x7f, 0xc7, 0x47, 0xd0, 0x46, 0x1e, 0x42, 0xdd, 0xa1};

        for (size_t i = 0; i < hash.size(); ++i)
        {
            REQUIRE(hash[i] == expected[i]);
        }
    }

    SECTION("Quick Brown Fox")
    {
        constexpr std::string_view source1{"The quick brown fox "};
        constexpr std::string_view source2{"jumps over the lazy dog.\n"};

        sha256_initialize(context);

        for (size_t i = 0; i < 16; ++i)
        {
            sha256_update(context, std::as_bytes(std::span{source1}));
            sha256_update(context, std::as_bytes(std::span{source2}));
        }

        auto const hash = sha256_finalize(context);

        constexpr uint8_t expected[]{
            0x1c, 0xec, 0x0d, 0x61, 0x3b, 0x13, 0x53, 0x73, 0xd0, 0x84, 0xc6, 0x86, 0x85, 0xb7, 0x47, 0x6f,
            0xb7, 0xc0, 0xd7, 0xf5, 0xca, 0xa2, 0x8f, 0x35, 0x94, 0x6e, 0xa6, 0xd3, 0x02, 0xba, 0x92, 0x25};

        for (size_t i = 0; i < hash.size(); ++i)
        {
            REQUIRE(hash[i] == expected[i]);
        }
    }
}
